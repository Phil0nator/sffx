#pragma once
#include "Particle.hpp"
#include <list>
#include <chrono>
#include "async/async.hpp"
#include "ParticleEvent.hpp"


namespace sffx
{


    /**
     * A ParticleEngine will own a series of particles, and particle events.
     * Behavior for these particles is managed in a seperate thread, and the 
     * engine can be used as an sf::Drawable at any time.
     * 
     * The Particles of the ParticleEngine are pointers owned by the engine. Any particles
     * or particle events given to the engine are liable to be deleted by the engine.
     */
    struct ParticleEngine : virtual public sf::Drawable
    {   
        // Principle list of particles
        std::list<Particle*> particles;
        // Principle list of particleEvents
        std::list<ParticleEvent*> events;
        // A list of new particles generated by other particles
        std::list<Particle*> newParticles;
        // An owner for the particle thread
        async::EventLoop particlethread;

        // Time to wait between particle ticks
        std::chrono::milliseconds timePerTick = std::chrono::milliseconds(50);
        
        // mutex's to sync threads
        mutable std::mutex mutsyncParticles; 
        mutable std::mutex mutsyncEvents;

        // used to delete the engine once it has finished
        bool alive = true;

        ParticleEngine() : particlethread(1) {}
        ParticleEngine(const ParticleEngine& other) = delete;
        ParticleEngine(ParticleEngine&& other) = delete;
        ParticleEngine(const ParticleEngine&& other) = delete;


        // Start the particle thread
        void start() noexcept;
        // Add a new particle
        void add(Particle* p) noexcept;
        // Add a new particle event
        void addEvent(ParticleEvent* event) noexcept;
        // Override to draw to target
        void draw(sf::RenderTarget& dest, sf::RenderStates states) const override;

        ~ParticleEngine();

    };

}
